C51 COMPILER V9.57.0.0   MAIN                                                              09/11/2019 18:29:36 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil\install\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**********************BST-V51实验开发板例程************************
   2          *  平台：BST-V51 + Keil U3 + STC89C52
   3          *  名称：18B20温度传感器模块测试
   4          *  公司：深圳市亚博软件开发有限公司
   5          *  修改日期：2019-9
   6          *  晶振:11.0592MHZ
   7          *  说明：免费开源，不提供源代码分析.
   8          *        ZhangHJ于2019-9-11进行测试,并修改部分代码及注释
   9          ******************************************************************/
  10          #include <reg52.h>
  11          #define uchar unsigned char
  12          #define uint unsigned int
  13          sbit DS = P2^2;         //define interface
  14          uint temp;              //variable of temperature
  15          uchar flag1;            //sign of the result positive or negative
  16          sbit dula = P2^6;       //定义数码管段选端口
  17          sbit wela = P2^7;       //定义数码管位选端口
  18          //定义数码管字符集
  19          unsigned char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x7
             -1};
  20          //定义数码管码表
  21          unsigned char code table1[]={0xbf,0x86,0xdb,0xcf,0xe6,0xed,0xfd,0x87,0xff,0xef};
  22          
  23          
  24          
  25          /**********************************************************
  26          *  函数名称：延时函数
  27          *  修改日期：2019-9-9
  28          *  修改人：ZhangHJ
  29          *  说明：低精度延时函数
  30          ***********************************************************/
  31          void delay(uint count)  //delay function
  32          {
  33   1        uint i;
  34   1        while(count)
  35   1        {
  36   2          i=200;
  37   2          while(i>0)
  38   2          i--;
  39   2          count--;
  40   2        }
  41   1      }
  42          
  43          
  44          
  45          /**********************************************************
  46          *  函数名称：发送复位和初始化命令函数 dsinit
  47          *  修改日期：2019-9-9
  48          *  修改人：ZhangHJ
  49          *  说明：1. 对于单片机: 单片机首先发出480-960us的低电平脉冲,
  50          *           释放总线为高电平(上拉电阻拉高),在随后的480us进行检测,
  51          *           如果出现低电平，说明器件应答正常.B
  52          *        2. 对于DS18B20: 上电后就检测是否有480/960us的低电平脉冲,
  53          *           如果有低电平,在总线释放之后，等待15-60us,
C51 COMPILER V9.57.0.0   MAIN                                                              09/11/2019 18:29:36 PAGE 2   

  54          *           将电平拉低60-240us,告诉主机已经准备好.
  55          ***********************************************************/
  56          void dsreset(void)        //send reset and initialization command
  57          {
  58   1        uint i;
  59   1        DS = 0;               //先将端口拉低
  60   1        i=103;                //维持低电平状态480us~960us
  61   1        while(i>0)i--;
  62   1        DS = 1;               //然后释放总线(将总线拉高),若DS18B20做出反应,将会将在15us~60us后将总线拉低
  63   1        i = 4;                //15us~60us等待
  64   1        while(i>0)i--;
  65   1      //  while(DS);
  66   1      //  i = 0;
  67   1      //  while(DS)             //在DS高电平时等待
  68   1      //  {
  69   1      //    i++;
  70   1      //    if(i > 5000)        //等待时间大于60us,说明响应失败
  71   1      //    {
  72   1      //      reutrn 0;
  73   1      //    }
  74   1      //  }
  75   1      //  return 1;
  76   1      }
  77          
  78          
  79          
  80          /**********************************************************
  81          *  函数名称：读1bit数据函数
  82          *  修改日期：2019-9-9
  83          *  修改人：ZhangHJ
  84          *  说明：1.首先单片机端口拉低 1 us (i++),
  85          *        2.然后释放总线,拉高总线,
  86          *        3.等待几位秒，是为了让 DS18B20 数据稳定,
  87          *        4.在15 us 内读取DS数据,
  88          *        5.接下来进行延时等待采样周期完成。
  89          *        详见DS18B20资料2.8.3.1读/写时间片
  90          ***********************************************************/
  91          bit tmpreadbit(void)    //read a bit data
  92          {
  93   1        uint i;
  94   1        bit dat;              //定义位数据 (dat = 0 or 1)
  95   1        DS = 0;               //先将端口拉低
  96   1        i++;                  //延时 1us
  97   1        DS = 1;               //再将端口拉高
  98   1        i++;i++;              //等待DS数据稳定
  99   1        dat = DS;             //数据传输
 100   1        i=8;while(i>0)i--;    //等待数据采样周期完成
 101   1        return (dat);
 102   1      }
 103          
 104          
 105          
 106          /**********************************************************
 107          *  函数名称：读1Byte数据函数
 108          *  修改日期：2019-9-9
 109          *  修改人：ZhangHJ
 110          *  说明：1.首先初始化字节数据变量dat为 0
 111          *        2.循环 8 次,调用tmpreadbit函数,读 8bit 数据
 112          *        3.读出的数据暂存到 j ,之后进行移位和按位或操作
 113          *        4.效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 114          *        5.最后返回读到的字节数据
 115          ***********************************************************/
C51 COMPILER V9.57.0.0   MAIN                                                              09/11/2019 18:29:36 PAGE 3   

 116          uchar tmpread(void)         //read a byte date
 117          {
 118   1        uchar i,j,dat;
 119   1        dat = 0;                  //初始化数据变量为 0
 120   1        for(i=1;i<=8;i++)         //循环 8 次,调用tmpreadbit函数,读 8bit 数据
 121   1        {
 122   2          j = tmpreadbit();       //读出的数据暂存到 j
 123   2          dat = (j<<7)|(dat>>1);  //效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 124   2        }
 125   1        return(dat);              //返回读到的字节
 126   1      }
 127          
 128          
 129          
 130          /**********************************************************
 131          *  函数名称：写入1Byte数据函数
 132          *  修改日期：2019-9-11
 133          *  修改人：ZhangHJ
 134          *  说明：1.将对待写入数据dat进行位操作,将dat末位数值赋值给位数据testb
 135          *        2.通过判断testb得到写 0 还是写 1
 136          *        3.若是写 0 操作,将 DS 拉低,进行<60us的延时,再将DS拉高,进行>1us的延时
 137          *        4.若是写 1 操作,将 DS 拉低,进行>1us的延时,再将DS拉高,进行<60us的延时
 138          *        5.循环执行2、3、4操作8次,写入1字节数据
 139          *        详见18B20资料“2.8.3.1读/写时间片”章节
 140          ***********************************************************/
 141          void tmpwritebyte(uchar dat)   //write a byte to ds18b20
 142          {
 143   1        uint i;
 144   1        uchar j;
 145   1        bit testb;
 146   1        for(j=1;j<=8;j++)
 147   1        {
 148   2          testb = dat&0x01;
 149   2          dat = dat>>1;
 150   2          if(testb)                 //write 1
 151   2          {
 152   3            DS=0;
 153   3            i++;i++;
 154   3            DS=1;
 155   3            i=8;while(i>0)i--;
 156   3          }
 157   2          else
 158   2          {
 159   3            DS = 0;                 //write 0
 160   3            i=8;while(i>0)i--;
 161   3            DS=1;
 162   3            i++;i++;
 163   3          }
 164   2        }
 165   1      }
 166          
 167          
 168          
 169          /**********************************************************
 170          *  函数名称：18B20温度转换函数
 171          *  修改日期：2019-9-11
 172          *  修改人：ZhangHJ
 173          *  说明：1.首先进行18B20初始化
 174          *        2.进行适当延时
 175          *        3.发送跳过光刻ROM指令
 176          *        4.发送RAM指令,进行温度转换
 177          *        详见18B20资料“2.8.3.1存储器操作命令”章节
C51 COMPILER V9.57.0.0   MAIN                                                              09/11/2019 18:29:36 PAGE 4   

 178          ***********************************************************/
 179          void tmpchange(void)          //DS18B20 begin change
 180          {
 181   1        dsreset();
 182   1        delay(1);
 183   1        tmpwritebyte(0xcc);         //address all drivers on bus
 184   1        tmpwritebyte(0x44);         //initiates a single temperature conversion
 185   1        //delay(100);               //not wait to change finish
 186   1      }
 187          
 188          
 189          
 190          /**********************************************************
 191          *  函数名称：18B20温度转换完整过程函数
 192          *  修改日期：2019-9-11
 193          *  修改人：ZhangHJ
 194          *  说明：1.首先进行18B20初始化
 195          *        2.进行适当延时
 196          *        3.发送跳过光刻ROM指令
 197          *        4.发送RAM指令,进行温度转换
 198          *        5.读取两个8位数据,放到16位寄存器 temp 中
 199          *        6.将读取到的二进制数据(默认为正数),转换为十进制数据
 200          *        7.返回温度数据
 201          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 202          ***********************************************************/
 203          uint tmp()                    //get the temperature
 204          {
 205   1        float tt;
 206   1        uchar a,b;
 207   1        dsreset();
 208   1        delay(1);
 209   1        tmpwritebyte(0xcc);         //读暂存寄存器
 210   1        tmpwritebyte(0xbe);
 211   1        a=tmpread();
 212   1        b=tmpread();
 213   1        temp=b;
 214   1        temp<<=8;                   //two byte compose a int variable
 215   1        temp=temp|a;
 216   1        tt=temp*0.0625;
 217   1        temp=tt*10+0.5;
 218   1        return temp;
 219   1      }
 220          
 221          
 222          
 223          /**********************************************************
 224          *  函数名称：读取ROM函数
 225          *  修改日期：2019-9-11
 226          *  修改人：ZhangHJ
 227          *  说明：使单片机读取DS18B20产品的序列号,暂时没有用到
 228          *        详见18B20资料“2.8.2.2ROM操作命令”章节
 229          ***********************************************************/
 230          //void readrom()                //read the serial
 231          //{
 232          //  uchar sn1,sn2;
 233          //  dsreset();
 234          //  delay(1);
 235          //  tmpwritebyte(0x33);
 236          //  sn1=tmpread();
 237          //  sn2=tmpread();
 238          //}
 239          
C51 COMPILER V9.57.0.0   MAIN                                                              09/11/2019 18:29:36 PAGE 5   

 240          
 241          
 242          /**********************************************************
 243          *  函数名称：10ms延时函数
 244          *  修改日期：2019-9-11
 245          *  修改人：ZhangHJ
 246          *  说明：延时10ms
 247          *        详见18B20资料“2.8.2.2ROM操作命令”章节
 248          ***********************************************************/
 249          //void delay10ms()              //delay 10ms
 250          //{
 251          //  uchar a,b;
 252          //  for(a=10;a>0;a--)
 253          //    for(b=60;b>0;b--);
 254          //}
 255          
 256          
 257          
 258          /**********************************************************
 259          *  函数名称：数码管温度数据显示函数
 260          *  修改日期：2019-9-11
 261          *  修改人：ZhangHJ
 262          *  说明：1.temp表示需要显示的温度数值(百位数值)
 263          *        2.A1、A2、A3分别了百位、十位、个位数值
 264          *        3.控制段选信号dula和位选信号wela,以使数码管显示
 265          ***********************************************************/
 266          void display(uint temp)       //显示程序
 267          {
 268   1         uchar A1,A2,A2t,A3,ser;
 269   1         ser=temp/10;
 270   1         SBUF=ser;
 271   1         A1=temp/100;               //A1 --> 百位
 272   1         A2t=temp%100;
 273   1         A2=A2t/10;                 //A2 --> 十位
 274   1         A3=A2t%10;                 //A3 --> 个位
 275   1         dula=0;
 276   1         P0=table[A1];              //显示百位
 277   1         dula=1;
 278   1         dula=0;
 279   1      
 280   1         wela=0;
 281   1         P0=0xfe;
 282   1         wela=1;
 283   1         wela=0;
 284   1         delay(1);
 285   1      
 286   1         dula=0;
 287   1         P0=table1[A2];             //显示十位
 288   1         dula=1;
 289   1         dula=0;
 290   1      
 291   1         wela=0;
 292   1         P0=0xfd;
 293   1         wela=1;
 294   1         wela=0;
 295   1         delay(1);
 296   1      
 297   1         P0=table[A3];              //显示个位
 298   1         dula=1;
 299   1         dula=0;
 300   1      
 301   1         P0=0xfb;
C51 COMPILER V9.57.0.0   MAIN                                                              09/11/2019 18:29:36 PAGE 6   

 302   1         wela=1;
 303   1         wela=0;
 304   1         delay(1);
 305   1      }
 306          
 307          
 308          
 309          void main()
 310          {
 311   1        uchar a;
 312   1        do
 313   1        {
 314   2          tmpchange();              //首次温度转换
 315   2          //delay(200);
 316   2          for(a=100;a>0;a--)        //延时,保持连续显示
 317   2          {
 318   3            display(tmp());         //进行温度转换和数值显示
 319   3          }
 320   2        }while(1);
 321   1      }
 322          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    466    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
